<?xml version="1.0" encoding="utf-8" ?>
<!--
设计说明：

	本脚本默认在 maven 环境下运行，也能够适应单独运行，但是需要外部的配置文件。运行的环境由脚本自动探测。

	脚本采用三个模型文件，存放在 src/main/model 下，文件名格式必须为 *.vo.jdl/*.bo.jdl/*.po.jdl 三种，
	分别对应 VO，BO和PO 对象。 在maven编译之前的 generate-source 阶段运行，代码的生成位置在 target 下，
	用同名的目录 vo，bo，po 分别对应三个不同的分层。三个分层使用的 jdl文件会在使用前复制到 target／vo|po|bo
    工程的 src/main/model/ 下。还会创建 node_modules 的目录链接，避免下载过多的软件。
	生成三个层次的工程代码之后，脚本会将这三个目录中的生成的代码内容复制到本目录之下，并组装这些代码。

	脚本会使用如下的属性变量，在maven环境下运行会自动生成这些属性值，非maven环境下从 powergen.properties 中获取：
		project_name     工程的名字， 默认是 project.artifactId
		project_package  工程的命名空间，默认是 project.groupId 
		project_dir      工程根目录，默认是 pom.xml 的目录
		output_dir       输出目录位置，存放各种中间状态的输出，默认是 target
		source_merge_dir 生成的代码最终合并到的目录位置，默认是 src/main/java 
		model_dir        存放 jdl 文件的目录位置，默认是 src/main/model
	
	代码分为： 环境设置 setenv， 工具类 tool，代码生成 gen几个部分，分别用相应的前缀作为 target的名字。
-->
<project name="powergen">

    <scriptdef name="dash-name" language="javascript">
        <attribute name="property"/>
        <attribute name="value"/>
        <![CDATA[
        value = attributes.get("value");
        arr = value.split("-");
        for(var i = 1; i < arr.length; i++)
            arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
        
        project.setProperty(attributes.get("property"), arr.join(""));
    ]]></scriptdef> 
    
    <target name="setenv.taskdef" depends="setenv.detect.sys, setenv.taskdef.maven, setenv.taskdef.ant">
    </target>

    <target name="setenv.detect.sys">
        <condition property="is-in-maven">
            <isset property="maven.project.artifactId" />
        </condition>

        <condition property="is-windows-os">
            <os family="windows" />
        </condition>
    </target>

    <target name="setenv.taskdef.maven" if="${is-in-maven}">
        <property name="plugin_classpath" refid="maven.plugin.classpath" />
        <!-- 装入antlib库 -->
        <taskdef resource="net/sf/antcontrib/antlib.xml" classpath="${plugin_classpath}" />
    </target>

    <target name="setenv.taskdef.ant" unless="is-in-maven">
        <!-- 装入antlib库 -->
        <taskdef resource="net/sf/antcontrib/antlib.xml" />
    </target>

    <target name="setenv.detect.project" depends="show-help">
        <condition property="has-yo_rc">
            <available file="${basedir}/.yo-rc.json" />
        </condition>
        <condition property="has-inited">
            <available file="${basedir}/mvnw" />
        </condition>
        <condition property="has-modules">
            <available file="${basedir}/node_modules" type="dir" />
        </condition>
    </target>
    
    <target name="setenv.vars.maven" if="${is-in-maven}" depends="setenv.detect.sys, setenv.taskdef">
        <property name="project_name" value="${maven.project.artifactId}" />

        <propertyregex property="project_package"
                       input="${maven.project.groupId}"
                       regexp="\-"
                       replace="_"
                       global="true"
                       defaultValue="${maven.project.groupId}" />

        <property name="project_dir" value="${basedir}" />
        <property name="output_dir" value="${basedir}/target" />
        <property name="source_merge_dir" value="${basedir}/src" />
        <property name="model_dir" value="${basedir}/src/main/model" />

    </target>

    <target name="setenv.vars.ant" unless="is-in-maven" depends="setenv.detect.sys">
        <property file="${basedir}/generate.properties" />
    </target>

    <!-- 设置系统变量的默认值 -->
    <target name="setenv.vars"
            depends="setenv.vars.defs, setenv.vars.maven, setenv.vars.ant, setenv.vars.check, setenv.vars.assert">
        <propertyregex property="project_package_dir"
                       input="${project_package}"
                       regexp="\."
                       replace="/"
                       global="true"
                       defaultValue="${project_package}" />

        <echo message="log level         = ${loglevel}" />
        <echo message="project name      = ${project_name}" />
        <echo message="project package   = ${project_package}" />
        <echo message="project root      = ${project_dir}" />
        <echo message="source merge dir  = ${source_merge_dir}" />
        <echo message="model input dir   = ${model_dir}" />
        <echo message="output dir        = ${output_dir}" />
        <echo message="package dir       = ${project_package_dir}" />
        <echo message="view layer name   = ${view-layer-name}" />
        <echo>---------</echo>
        <echo message="clean-gen-source  = ${clean-gen-source}" />
        <echo message="skip-build        = ${skip-build}" />
        <echo message="skip-build-vo     = ${skip-build-vo}" />
        <echo message="skip-build-bo     = ${skip-build-bo}" />
        <echo message="skip-build-po     = ${skip-build-po}" />
        <echo>---------</echo>
        <echo message="force-build       = ${force-build}" />
        <echo message="force-build-vo    = ${force-build-vo}" />
        <echo message="force-build-bo    = ${force-build-bo}" />
        <echo message="force-build-po    = ${force-build-po}" />
        <echo>---------</echo>
        <echo message="skip-gen          = ${skip-gen}" />
        <echo message="skip-gen-vo       = ${skip-gen-vo}" />
        <echo message="skip-gen-bo       = ${skip-gen-bo}" />
        <echo message="skip-gen-po       = ${skip-gen-po}" />
    </target>

    <target name="setenv.vars.defs">
        <property name="loglevel" value="debug" />

        <property environment="env" />

        <property name="clean-gen-source" value="false" />
        <!-- 默认的 view 层的package名称，允许针对不同的设备定义名字 -->
        <property name="view-layer-name" value="view" />
        
        <property name="skip-build" value="false" />
        <property name="skip-build-vo" value="false" />
        <property name="skip-build-bo" value="false" />
        <property name="skip-build-po" value="false" />

        <property name="force-build" value="false" />
        <property name="force-build-vo" value="false" />
        <property name="force-build-bo" value="false" />
        <property name="force-build-po" value="false" />

        <property name="skip-gen" value="false" />
        <property name="skip-gen-vo" value="false" />
        <property name="skip-gen-bo" value="false" />
        <property name="skip-gen-po" value="false" />
    </target>

    <target name="setenv.options">
        <!-- 记录日志 error|warn|info|verbose|debug -->
        <record name="${basedir}/target/logs/generate.log" loglevel="${loglevel}" action="start" />
    </target>


    <target name="setenv.vars.check">
        <mkdir dir="${output_dir}/logs" />
        <condition property="vars_valid">
            <and>
                <available file="${project_dir}" type="dir" />
                <available file="${output_dir}" type="dir" />
                <available file="${source_merge_dir}" type="dir" />
                <available file="${model_dir}" type="dir" />
            </and>
        </condition>
    </target>

    <target name="setenv.vars.assert" unless="vars_valid">
        <fail message="vars definition invalid" />
    </target>

    <target name="setenv"
            depends="setenv.detect.sys, setenv.vars, setenv.options, setenv.taskdef, setenv.detect.project">
    </target>

    <target name="show-help">
        <echo message="============= HELP =================" />
        <echo message="命令行参数控制: " />
        <echo message="-Dview-layer-name=view   指定vo层的package名称，默认是view" />
        <echo message="-Dskip-build=true     跳过 vo, bo, po 的构建" />
        <echo message="-Dskip-build-vo=true  跳过 vo 的构建" />
        <echo message="-Dskip-build-po=true  跳过 po 的构建" />
        <echo message="-Dskip-build-bo=true  跳过 bo 的构建" />
        <echo message="-Dforce-build=true     强制 vo, bo, po 的构建" />
        <echo message="-Dforce-build-vo=true  强制 vo 的构建" />
        <echo message="-Dforce-build-po=true  强制 po 的构建" />
        <echo message="-Dforce-build-bo=true  强制 bo 的构建" />
        <echo message="-Dskip-gen=true     跳过 vo, bo, po 的代码生成" />
        <echo message="-Dskip-gen-vo=true  跳过 vo 的代码生成" />
        <echo message="-Dskip-gen-po=true  跳过 po 的代码生成" />
        <echo message="-Dskip-gen-bo=true  跳过 bo 的代码生成" />
    </target>

    <target name="clean" depends="setenv">
        <echo>clean generated sources in src/ directory by -Dpowergen.fullclean=true</echo>
        <echo>clean above and node_modules/ by -Dpowergen.deepclean=true</echo>
        <!-- if -Dpowergen.fullclean=true then clear copied source -->
        <if>
            <or>
                <istrue value="${powergen.fullclean}" />
                <istrue value="${powergen.deepclean}" />
            </or>
            <then>
                <var name="gen.clean-gen" value="true"/>
                <antcall target="gen.clean-gen">
                </antcall>
                <!-- 删除 node-modules -->
                <if>
                    <istrue value="${powergen.deepclean}" />
                    <then>
                        <antcall target="tool.removelink">
                            <param name="from.dir" value="${project_dir}/node_modules" />
                        </antcall>
                        <delete quiet="false" failonerror="false" verbose="false" removeNotFollowedSymlinks="true" includeemptydirs="true" >
                            <fileset dir="${project_dir}" defaultexcludes="no" >
                                <include name="node_modules/**/*" />
                            </fileset>
                        </delete>
                        <delete quiet="false" failonerror="false" verbose="false" removeNotFollowedSymlinks="true" includeemptydirs="true" >
                            <dirset dir="${project_dir}" defaultexcludes="no" >
                                <include name="node_modules/**" />
                            </dirset>
                        </delete>
                    </then>
                </if>
            </then>
        </if>
                
    </target>    
    
    <!-- 先清除复制到src中的源代码 -->
    <target name="gen.clean-gen" if="${clean-gen-source}">
        <echo>cleaning generated files in src/ ... </echo>
        <delete quiet="false" failonerror="false" verbose="true" removeNotFollowedSymlinks="true" >
            <fileset dir="${project_dir}" followsymlinks="false" >
                <include name="*.*" />
                <include name="*" />
                <include name="**/*" />
                <include name="**/*.*" />
                <exclude name="node_modules/**/*" />
                <exclude name="node_modules/**/*.*" />
                <exclude name="node_modules/**/.*" />
                <exclude name="pom.xml" />
                <exclude name="generate.properties" />
                <exclude name=".yo-rc.json" />
                <exclude name="src/main/model/**/*" />
                <exclude name="src/main/model/**/*.*" />
                <exclude name="target/**/*" />
                <exclude name=".idea/**/*" />
                <exclude name="*.iml" />
                <exclude name=".settings/**/*" />
                <exclude name="*.project" />
                <exclude name="*.classpath" />
            </fileset>
        </delete>
        <delete quiet="false" failonerror="false" verbose="true" removeNotFollowedSymlinks="true" includeemptydirs="true" >
            <dirset dir="${project_dir}" defaultexcludes="no" >
                <include name="*" />
                <include name="*.*" />
                <include name="**" />
                <exclude name="node_modules/**" />
                <exclude name="src/main/model/**" />
                <exclude name="target" />
                <exclude name=".idea" />
                <exclude name=".settings" />
            </dirset>
        </delete>
    </target>
    
    <target name="generate" depends="setenv"  >
        <script language="groovy">
            ant = new AntBuilder()
            
            def nsMap = {vo: "${view-layer-name}", bo: "business", po: "po"}
            
            build(){
                ["vo", "bo", "po"].each{layer ->
                    if( force_build || "force_build_
                    initDir()
                    generateSource()
                    copyBack()
                    processSource()
                }
            }
            fix()
            
        </script>
    
    </target>
    
    <target name="generate-1" depends="setenv, gen.mkdir, gen.yo_rc, gen.init, gen.clean-gen">
        <echo message="generate ..." />

        <for list="vo,bo,po" param="layer">
            <sequential>
                <var name="target_layer" value="@{layer}" />
                <var name="is_@{layer}" value="true" />
                <if>
                    <or>
                        <!-- 如果有强迫生成 -->
                        <istrue value="${force-build}" />
                        <istrue value="${force-build-@{layer}}" />
                        <and>
                            <!-- 没有设置各种跳过 -->
                            <isfalse value="${skip-build}" />
                            <isfalse value="${skip-build-@{layer}}" />
                            <!-- target中jdl文件存在而且model里的jdl更加新 -->
                            <or>
                                <not>
                                    <available file="${output_dir}/${target_layer}/${project_name}.${target_layer}.jdl" />
                                </not>
                                <!-- 如果model中文件比target里的新 -->
                                <uptodate targetfile="${model_dir}/${project_name}.${target_layer}.jdl"
                                          srcfile="${output_dir}/${target_layer}/${project_name}.${target_layer}.jdl" />
                            </or>
                        </and>
                    </or>
                    <then>
                        <var name="can_gen" value="true" />
                        <if>
                            <or>
                                <istrue value="${skip-gen}" />
                                <istrue value="${skip-gen-@{layer}}" />
                            </or>
                            <then>
                                <echo>ignore generate @{layer} when skip-gen=${skip-gen} or skip-gen-@{layer}=${skip-gen-@{layer}}</echo>
                                <var name="can_gen" value="false" />
                            </then>
                        </if>
                        <!-- 依次处理每一个层 -->
                        <echo>starting generating @{layer}: is_@{layer}=${is_@{layer}} ...</echo>

                        <antcall target="gen.layer">
                        </antcall>

                        <var name="can_gen" value="false" />
                        <var name="is_@{layer}" value="false" />
                        <echo>finish generating @{layer}: is_@{layer}=${is_@{layer}} ...</echo>
                    </then>
                </if>
                <var name="is_@{layer}" value="false" />
            </sequential>
        </for>

        <antcall target="gen.improve">
        </antcall>

        <echo message="generate OK!" />
    </target>

    <target name="gen.yo_rc" unless="has-yo_rc">
        <echo file="${project_dir}/.yo-rc.json" append="false">{
  "generator-jhipster": {
    "promptValues": {
      "packageName": "${project_package}",
      "nativeLanguage": "en"
    },
    "jhipsterVersion": "4.5.2",
    "baseName": "${project_name}",
    "packageName": "${project_package}",
    "packageFolder": "${project_package_dir}",
    "serverPort": "8080",
    "authenticationType": "session",
    "hibernateCache": "ehcache",
    "clusteredHttpSession": false,
    "websocket": false,
    "databaseType": "sql",
    "devDatabaseType": "h2Disk",
    "prodDatabaseType": "mysql",
    "searchEngine": false,
    "messageBroker": false,
    "serviceDiscoveryType": false,
    "buildTool": "maven",
    "enableSocialSignIn": false,
    "rememberMeKey": "e832ea76e42281686f61160e8e37d3b5c9707a64",
    "clientFramework": "angular1",
    "useSass": false,
    "clientPackageManager": "yarn",
    "applicationType": "monolith",
    "testFrameworks": [],
    "jhiPrefix": "jhi",
    "enableTranslation": true,
    "nativeLanguage": "en",
    "languages": [
      "en",
      "zh-cn"
    ]
  }
}
		</echo>
    </target>

    <target name="gen.init" unless="has-inited">

    </target>

    <target name="gen.mkdir">
        <mkdir dir="${output_dir}" />

        <property name="vo_dir" value="${output_dir}/vo" />
        <property name="bo_dir" value="${output_dir}/bo" />
        <property name="po_dir" value="${output_dir}/po" />

        <property name="packagename.vo" value="${view-layer-name}" />
        <property name="packagename.bo" value="business" />
        <property name="packagename.po" value="po" />

        <mkdir dir="${vo_dir}" />
        <mkdir dir="${bo_dir}" />
        <mkdir dir="${po_dir}" />
    </target>

    <!-- 所有 gen. 开头的都依赖于 target_layer 属性。
    处理步骤：1. copy基本模型， 2. build工程， 3.装入模型附加信息load_jdl， 4. merge公共内容， 5. process个体， 6. fix修复和链接
    -->
    <target name="gen.layer" depends="gen.copy, gen.build, gen.load_jdl, gen.merge, gen.process, gen.fix">

    </target>

    <target name="gen.copy" if="${can_gen}">
        <!-- 复制当前工程的基本配置文件 -->
        <echo>coping yo-rc</echo>
        <copy file="${project_dir}/.yo-rc.json" todir="${output_dir}/${target_layer}" overwrite="true" />
        
        <!-- 复制 jdl 文件，除了生成 base 结构 -->
        <echo>copy ${project_name}.${target_layer}.jdl </echo>
        <copy file="${model_dir}/${project_name}.${target_layer}.jdl"
              tofile="${output_dir}/${target_layer}/${project_name}.${target_layer}.jdl"
              overwrite="true" />
  
        <!-- 让不同的层生成内容在不同的命名空间中 -->
        <propertycopy name="layer_ns" from="packagename.${target_layer}" />
        <replace file="${output_dir}/${target_layer}/.yo-rc.json"
                 token="${project_package}"
                 value="${project_package}.${layer_ns}" />
        <replace file="${output_dir}/${target_layer}/.yo-rc.json"
                 token="${project_package_dir}"
                 value="${project_package_dir}/${layer_ns}" />

        <if>
            <not>
                <available file="${output_dir}/${target_layer}/node_modules" type="dir" />
            </not>
            <then>
                <echo>linking node_modules</echo>
                <!-- 准备链接 node_modules -->
                <antcall target="tool.link">
                    <param name="from.dir" value="${project_dir}/node_modules" />
                    <param name="to.link" value="${output_dir}/${target_layer}/node_modules" />
                </antcall>
            </then>
        </if>
    </target>

    <target name="gen.load_jdl" >
        <!-- 分析jdl文件，提取处理时候需要的信息，包括 
            jdl.content 存放jdl内容，以便后续处理
            jdl.entity.list 存放逗号分隔的jdl中所有实体名称列表
            jdl.entity.dash-list 存放中划线分隔的jdl中所有实体名称列表
            jdl.entity.relation.json 存放基于json结构的实体和实体关系信息
         -->
        <loadfile property="jdl.content" srcfile="${output_dir}/${target_layer}/${project_name}.${target_layer}.jdl">
        </loadfile>
        <script language="javascript"><![CDATA[
            function show(msg){
                echo = project.createTask("echo");
                echo.setMessage(msg);
                echo.perform()
            }
            
            function eachArr(arr, func){
                if( arr != null && arr.length > 0 )
                    for(var i = 0; i < arr.length; ++i)
                        func(arr[i], i);
            }
            
            function eachMatch(text, regex, func){
                var result;
                while ((result = regex.exec(text)) != null){
                    func(result);
                }
            }
            
            function pushItemAsString(arr, item){
                arr.push("\"");
                arr.push(item);
                arr.push("\"");
            }
            
            jdlContent = project.getProperty("jdl.content");
            // 查找提取所有的实体名称
            var arr = [];
            eachMatch(jdlContent, /entity\s+(\w+)\s*\{/g, function(result){ arr.push(result[1]); });

            var list = arr.join(",");
            
            project.setProperty("jdl.entity.list", list);
            project.setProperty("jdl.entity.dash-list", list.replace( /(.)?\s*([A-Z])/g, 
                function($0, $1, $2){
                    return ($1 == null? "" : ($1 == "," ? $1: $1 + "-")) + $2.toLowerCase(); 
                })
            );
           
            // 提取entity前面的注释，以及entity相关的所有关系
            var c_comment = "\\/\\*(?:(?!\\*\\/).|[\\n\\r])*\\*\\/";
            var line_comment = "^\\s*\\/\\/.*[\\r\\n]+";
            var maybe_space = "[\\r\\n\\s]*";
            var req_space = "[\\r\\n\\s]+";
            
            var entity_pattern = "((" + line_comment + ")|(" + c_comment + "))" + maybe_space + // $1 $2 $3
                                 "entity" + req_space + "(\\w+)" + maybe_space + "\\{";   // $4 $5
            entityMap = {};
            eachMatch(jdlContent, new RegExp(entity_pattern, "gm"), 
                function(result){
                    // 将实体相关的注释信息放入 entity: [开头注释，[关系，方向, 目标实体, 注释], [], ...]
                    entityMap[result[4]] = [ result[0] ];
                    //show(result[4] + ":" + result[0] + "\r\n------");
                }
            );
            
            // 提取relationship中定义的所有关系内容
            var relation_pattern = "((" + line_comment + ")|(" + c_comment + "))" + maybe_space + // $1 $2 $3
                                "(\\w+)" + maybe_space + "(\\{.*\\})?" +  // $4 $5
                                req_space + "to" + req_space + 
                                "((" + line_comment + ")|(" + c_comment + "))" + maybe_space + // $6 $7 $8 
                                "(\\w+)" + maybe_space + "(\\{.*\\})?" + // $9 $10 
                                "[,\\r\\n\\s]+" + maybe_space;
            var relationship_pattern = "relationship\\s+(\\w+)" + maybe_space + "\\{" + maybe_space + // $1
                        "(" + relation_pattern + ")+" + maybe_space +
                        "\\}";
            
            var regRelation = new RegExp(relation_pattern, "gm");
            var arr_relationship = jdlContent.match(new RegExp(relationship_pattern, "gm"));
            
            eachArr(arr_relationship, function(rel_block){
                var result = /relationship\s+(\w+)/.exec(rel_block);
                var relationType = result[1];
                
                eachMatch(rel_block, regRelation, function(result){
                    // 将实体相关的注释信息放入，双向放入。[关系，方向, 目标实体, 注释]
                    entityMap[result[4]].push([relationType, "forward", result[9], result[1] ]);
                    entityMap[result[9]].push([relationType, "backward", result[4], result[6] ]);
            
                    //show("---" + result + " ===" )
                });
            });
            //show("entityMap ==>" + entityMap);
            
            // 将每个entity关联的信息里所有 pg- 开头的信息全部提取，存放到 json 中
            // 存放格式是 entity : {pg-KEY: value, ...}
            relationJson = [];
            var matchKV = /^.*(pg\-[\w\d\-]+)\s*:\s*(.+)\s*$/gm
            relationJson.push("{");
            eachArr( arr, function(ent, arrIdx){
                //show("ent : " + ent);
                
                if( arrIdx != 0 ) relationJson.push(",");
                pushItemAsString(relationJson, ent);
                relationJson.push(": {");
            
                eachArr(entityMap[ent], function(item, idx){
                    //show(" item of ent: " + item );
                    eachMatch( idx == 0? item: item[3], matchKV, function(result){
                        pushItemAsString(relationJson, result[1]);
                        relationJson.push(":");
                        pushItemAsString(relationJson, result[2]);
                        relationJson.push(",");
                        // 自动生成pg-relation-XXX的属性
                        if( idx != 0 ) {
                            relationlist.push(item[2]);
            
                            pushItemAsString(relationJson, "pg-relationship-" + item[2]);
                            relationJson.push(":");
                            pushItemAsString(relationJson, item[0]);
                            relationJson.push(",");
            
                            pushItemAsString(relationJson, "pg-relation-dir-" + item[2]);
                            relationJson.push(":");
                            pushItemAsString(relationJson, item[1]);
                            relationJson.push(",");
                        }
                    });
                });
            
                relationJson.push("}");
            });
            relationJson.push("}");
                        
            project.setProperty("jdl.entity.relation.json", relationJson.join(""));
        ]]></script>        
        <echo level="debug">
            ${jdl.entity.list} 
            ${jdl.entity.dash-list} 
            ${jdl.entity.relation.json}
        </echo>
    </target>
      
    <target name="gen.process">
        <echo>processing each entities!</echo>
        <antcall target="eachEntity" inheritAll="true" >
            <param name="callback-target" value="gen.process.${target_layer}-entity" />
        </antcall>
    </target>

    <!-- 参数： callback-target 回掉的函数名 -->
    <target name="eachEntity" >
        <!--
        jdl.entity.list 存放逗号分隔的jdl中所有实体名称列表
        jdl.entity.dash-list 存放中划线分隔的jdl中所有实体名称列表
        jdl.entity.relation.json 存放基于json结构的实体和实体关系信息
        -->
        <for list="${jdl.entity.list}" param="ent">
            <sequential>
                <!-- 提取 json 中 entity 相关的参数，并把它设置成 property -->
                <!-- 提取 dash-name -->
                <script language="javascript"><![CDATA[
                    project.setProperty("entity.dash-name", "@{ent}".replace( /(.)?\s*([A-Z])/g, 
                        function($0, $1, $2){
                            return ($1 == null? "" : ($1 == "," ? $1: $1 + "-")) + $2.toLowerCase(); 
                        })
                    );  
                ]]></script>   
                <!-- 调用回调函数，利用antcall产生的作用域切换，隔离每次循环的创建的property，避免相互影响 -->
                <antcall target="eachEntity.each" inheritAll="true" >
                    <param name="entity.name" value="@{ent}" />
                    <propertyset negate="true" >
                        <propertyref prefix="pg-"/>
                    </propertyset>
                </antcall>
            </sequential>
        </for>         
    </target>
    
    <target name="eachEntity.each" >
        <!-- 提取 json 中 entity 相关的参数，并把它设置成 property -->
        <!-- 提取 dash-name -->
        <script language="javascript"><![CDATA[
            eval("entityConfig = " + project.getProperty("jdl.entity.relation.json"));
            
            ent = project.getProperty("entity.name")
            cfg = entityConfig[ent];
            
            for(var prop in cfg){
                if( prop.substring(0,3) == "pg-" ){
                    project.setProperty(prop, cfg[prop]);
                }
            }
        ]]></script>   
        <!-- 调用回调函数 -->
        <antcall target="${callback-target}" inheritAll="true" >
        </antcall>
    </target>
    
    <!--  目前 jdl 中每一个实体可以指定 
    pg-state:delete,edit,brief-edit,brief,detail,list, list-edit，手工属性，默认全部都要
    pg-brief-of: YYY 当前对象是 YYY 对象的简化， 手工属性。处理时会将当前对象复制到 YYY 的目录下并改名
    pg-map-to: YYY   映射view对象到YYY对象的BO，手工属性
    pg-view：XXX,YYY, ... 帮助在 app/views/下生成特定的视图，里边包含 directive 组合的页面，手工属性
    pg-relationship-XXX: 当前对象和 XXX 实体的关联关系，自动生成属性
    pg-relation-dir-XXX: 当前对象和 XXx 实体关系的关联方向，自动生成属性
    可用变量： entity.name, entity.dash-name
    -->
    <target name="gen.process.vo-entity" if="${is_vo}">
        <!-- 显示环境参数 -->
        <echo>processing ${entity.name} / ${entity.dash-name} </echo>
        <propertyselector property="pg.list"
                                 delimiter=","
                                 match="(pg\-.+)"
                                 select="\1"
                                 casesensitive="false" />
        <if>
            <isset property="pg.list" />
            <then>
                <echo>properties: </echo>
                <for list="${pg.list}" param="prop">
                    <sequential>
                        <echo>@{prop} = ${@{prop}}</echo>
                    </sequential>
                </for>
            </then>
        </if>
        <!-- 处理每一个 entity 相关的文件，逻辑如下：
        1. 将 *ViewDTO 修改成 *View
        2. 提取html的内容，生成相关的 directive
        -->
        <copy todir="${source_merge_dir}/main/webapp/" verbose="true" >
            <fileset dir="${output_dir}/${target_layer}/src/main/webapp">
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}-delete-dialog*.*" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}-detail*.*" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}-dialog*.*" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}-edit*.*" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}-info*.*" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}-list-edit*.*" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}-list*.*" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}s.html" />
                <include name="app/entities/${entity.dash-name}/${entity.dash-name}.*.js" />
            </fileset>
        </copy>
        <copy todir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" verbose="true" >
            <fileset dir="${output_dir}/${target_layer}/src/main/java/${project_package_dir}/${view-layer-name}">
                <include name="web/rest/${entity.name}Resource.java" />
                <include name="service/${entity.name}Service.java" />
                <include name="service/impl/${entity.name}ServiceImpl.java" />
                <include name="service/mapper/${entity.name}Mapper.java" />
                <include name="service/dto/${entity.name}.java" />
            </fileset>
        </copy>
        <!-- 提取所有app/entities/* 中的 html 片段，形成 directive，以便重用 -->
        <for param="file">
            <path>
                <fileset dir="${source_merge_dir}/main/webapp/app/entities/${entity.dash-name}" includes="*.html" />
            </path>
            <sequential>
                <antcall target="gen.process.vo.gen-directive" >
                    <param name="filepath" value="@{file}" />
                </antcall>
                <!--  -->
                <!--  -->
            </sequential>
        </for>       
    </target>
        
    <target name="gen.process.bo-entity" if="${is_bo}">
    </target>
        
    <target name="gen.process.po-entity" if="${is_po}">
    </target>
        
        
    <target name="gen.build" if="${can_gen}">
        <!-- 只有没设置 skip-build-XX 的时候才运行 -->
        <for list="${target_layer}" param="proj">
            <sequential>
                <if>
                    <istrue value="${is-windows-os}" />
                    <then>
                        <pathconvert property="proj-dir-@{proj}" targetos="windows">
                            <path location="${output_dir}/${target_layer}" />
                        </pathconvert>
                        <echo message="... building ${proj-dir-@{proj}} ..." />
                        <shellscript shell="cmd.exe"
                                     tmpsuffix=".bat"
                                     dir="${proj-dir-@{proj}}"
                                     osfamily="windows"
                                     failonerror="true">
                            <arg value="/c" />
                            <arg value="call" />
							yo jhipster --force
							if "%errorlevel%" == "0" (
                                if not exist "${proj-dir-@{proj}}\src" echo "======src not generated======" &amp;&amp; exit 1
							    if exist "${project_name}.@{proj}.jdl" (    
							        echo ================generate from ${project_name}.@{proj}.jdl======================
							        yo jhipster:import-jdl ${project_name}.@{proj}.jdl --force
							    )
							) else (
                                echo "======src not generated======" &amp;&amp; exit 1
                            )
						</shellscript>
                    </then>
                    <else>
                        <echo message="... building @{proj} ..." />
                        <shellscript shell="bash"
                                     dir="${output_dir}/${target_layer}"
                                     osfamily="unix"
                                     failonerror="true">
							yo jhipster --force
							if [ "$?" -eq "0"  -a  -f "${project_name}.@{proj}.jdl" ]
							then
                                [ ! -d "${output_dir}/${target_layer}/src" ] &amp;&amp; echo "=====[${output_dir}/${target_layer}/src] not generated======" &amp;&amp; exit 1
							    echo "================generate from ${project_name}.@{proj}.jdl======================"
								yo jhipster:import-jdl ${project_name}.@{proj}.jdl --force
							fi
						</shellscript>
                    </else>
                </if>
                <echo>building filished!</echo>
            </sequential>
        </for>

        <if>
            <istrue value="${is_vo}" />
            <then>
                <antcall target="gen.vo.post-gen">
                </antcall>
            </then>
        </if>
    </target>

    <target name="gen.vo.post-gen">
        <!-- 判断是否存在project目录的 node_modules,如果没有则移动一个，且为 vo 建立 link -->
        <if>
            <and>
                <not>
                    <available file="${project_dir}/node_modules" type="dir" />
                </not>
                <available file="${output_dir}/${target_layer}/node_modules" type="dir" />
            </and>
            <then>
                <echo>moving node_modules for standard</echo>
                <move todir="${project_dir}/node_modules" >
                    <dirset dir="${output_dir}/${target_layer}/node_modules" />
                </move>
                <antcall target="tool.link">
                    <param name="from.dir" value="${project_dir}/node_modules" />
                    <param name="to.link" value="${output_dir}/${target_layer}/node_modules" />
                </antcall>
            </then>
        </if>
    </target>

    <target name="tool.link">
        <!-- 如果当前不存在，则寻找 node_modules 将其 link 到目标目录 -->
        <if>
            <and>
                <available file="${from.dir}" type="dir" />
                <not>
                    <available file="${to.link}" type="dir" />
                </not>
                <not>
                    <available file="${to.link}" type="file" />
                </not>
            </and>
            <then>
                <echo message="... linking ${from.dir} to ${to.link} ..." />
                <pathconvert property="local-dir" targetos="windows">
                    <path location="${from.dir}" />
                </pathconvert>
                <basename property="linkdir" file="${to.link}" />
                <exec dir="${linkdir}" executable="cmd.exe" osfamily="windows" failonerror="true">
                    <arg line='/c mklink /j node_modules "${local-dir}" ' />
                </exec>
                <exec dir="${linkdir}" executable="/bin/ln" osfamily="unix" failonerror="true">
                    <arg line="-s ${from.dir} ${to.link}" />
                </exec>
                <if>
                    <and>
                        <not>
                            <available file="${to.link}" type="dir" />
                        </not>
                        <not>
                            <available file="${to.link}" type="file" />
                        </not>
                    </and>
                    <then>
                        <fail message="link failure: ${to.link} not exist" />
                    </then>
                </if>
            </then>
            <else>
                <echo message="... link ${from.dir} to ${to.link} ignored!" />
            </else>
        </if>
    </target>

    <target name="tool.removelink">
        <echo message="... remove links from ${from.dir} ..." />
        <pathconvert property="local-dir" targetos="windows">
            <path location="${from.dir}" />
        </pathconvert>
        <exec dir="${from.dir}" outputproperty="symlinks" executable="cmd.exe" osfamily="windows" failonerror="true">
            <arg line='/c dir /A:L /b /s "${local-dir}" ' />
        </exec>
        <exec dir="${from.dir}" outputproperty="symlinks" executable="bash" osfamily="unix" failonerror="true">
            <arg value="-c"/>
            <arg value="find . -type l"/>
        </exec>

        <echo>[${symlinks}]</echo>
        <for list="${symlinks}" delimiter="${line.separator}" param="link" >
            <sequential>
                <if>
                    <istrue value="${is-windows-os}" />
                    <then>
                        <echo>delete symbolic link @{link}</echo>
                        <delete file="@{link}" removeNotFollowedSymlinks="true" verbose="true" />  
                    </then>
                    <else>
                        <echo>delete symbolic link ${from.dir}/@{link}</echo>
                        <delete file="${from.dir}/@{link}" removeNotFollowedSymlinks="true" verbose="true" />                    
                    </else>
                </if>
            </sequential>
        </for>    

    </target>


    <!-- 从生成代码中获取需要的部分，并交给 gen.fix 处理 -->
    <target name="gen.merge" depends="gen.merge.vo, gen.merge.bo, gen.merge.po">
        
    </target>

    <target name="gen.merge.vo" if="${is_vo}">
        <if>
            <isfalse value="${is_vo}" />
            <then>
                <fail message="is_vo == false " />
            </then>
        </if>
        <fail message="assert is_vo=false" unless="is_vo" />

        <echo>copy project files for init</echo>
        <!-- 需要原封不动复制的文件 -->
        <copy todir="${project_dir}" overwrite="false">
            <fileset dir="${output_dir}/${target_layer}">
                <include name="*.*" />
                <include name="gulp/*.*" />
                <include name="src/test/**/*.*" />
                <include name="src/main/docker/**/*.*" />
                <include name="src/main/resources/**/*.*" />
                <include name="src/main/webapp/**/*.*" />
                
                <include name="src/main/webapp/entities/*.*" />
                <exclude name="src/main/webapp/entities/**/*.*" />
                
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/*.*" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/web/*.*" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/web/rest/AccountResource.java" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/web/rest/AuditResource.java" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/web/rest/LogsResource.java" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/web/rest/ProfileInfoResource.java" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/web/rest/UserResource.java" />
                <exclude name="src/main/java/${project_package_dir}/${view-layer-name}/web/rest/*.*" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/web/rest/**/*.*" />
                
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/service/dto/UserDTO.java" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/service/mapper/EntityMapper.java" />
                <include name="src/main/java/${project_package_dir}/${view-layer-name}/service/mapper/UserMapper.java" />
                
                <exclude name="*.jdl" />
                <exclude name="*.jh" />
                <exclude name="pom.xml" />
                <exclude name=".yo-rc.json" />
                <exclude name="target/**/*.*" />
                <exclude name="node_modules/**/*.*" />
                <exclude name="src/main/java/${project_package_dir}/${view-layer-name}/aop/**/*.*" />
                <exclude name="src/main/java/${project_package_dir}/${view-layer-name}/config/**/*.*" />
                <exclude name="src/main/java/${project_package_dir}/${view-layer-name}/domain/**/*.*" />
                <exclude name="src/main/java/${project_package_dir}/${view-layer-name}/repository/**/*.*" />
                <exclude name="src/main/java/${project_package_dir}/${view-layer-name}/security/**/*.*" />
            </fileset>
        </copy>
        <!-- 需要移动package的文件 -->
        <copy todir="${source_merge_dir}/main/java/${project_package_dir}/" verbose="true" >
            <fileset dir="${output_dir}/${target_layer}/src/main/java/${project_package_dir}/${view-layer-name}">
                <include name="security/**/*.*" />
                <!-- CacheConfiguration用 PO 的 -->
                <exclude name="security/CacheConfiguration.java" />
            </fileset>
        </copy>
        
        <!-- 备份原始pom文件 -->
        <if>
            <not>
                <available file="${project_dir}/pom.origin.xml" />
            </not>
            <then>
                <echo message="备份原始pom文件" />
                <move file="${project_dir}/pom.xml" tofile="${project_dir}/pom.origin.xml" />
                <copy file="${output_dir}/${target_layer}/pom.xml" tofile="${project_dir}/pom.xml" />
                <property name="parent_ref" ><![CDATA[
    <parent>
        <groupId>com.github.powergen</groupId>
        <artifactId>powergen-parent</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../powergen-parent/pom.xml</relativePath>
    </parent> 
                    ]]>
                </property>
                <!-- 替换parent部分内容  -->
                <replaceregexp match="\&lt;parent\&gt;[\w\d\-\&gt;\&lt;\.\r\n\s/]+\&lt;/parent\&gt;" replace="${parent_ref}" flags="gm">
                    <fileset dir="${project_dir}" includes="pom.xml" />
                </replaceregexp>  
                <!-- 修改 groupId 和 artifactId -->
                <replaceregexp match="${project_package}.${view-layer-name}" replace="${project_package}" flags="gm">
                    <fileset dir="${project_dir}" includes="pom.xml" />
                </replaceregexp>  
            </then>
        </if>        
    </target>

    <!-- 修复 VO 内部的链接关系，确保没有编译错误 
	*.config.CacheConfiguration.java需要插入关联内容, // jhipster-needle-ehcache-add-entry
	-->
    <target name="gen.fix.vo" if="${is_vo}">
        <!-- 将所有的 View 替换成 Business,同时修改import *.view.domain.*View 转到 *.business.domain.*BO -->
        <replaceregexp match="(\w+)View\b" replace="\1BO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.${view-layer-name}\.domain\.(\w+)BO" replace=".business.domain.\1BO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.${view-layer-name}\.domain\." replace=".business.domain." flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.${view-layer-name}\.security\b" replace=".security" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/security" includes="**/*.java" />
        </replaceregexp>
        <!-- 将 ViewDTO 转到 View -->
        <replaceregexp match="(\w+)ViewDTO\b" replace="\1View" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
        </replaceregexp>
        <!-- 替换 ViewServiceImpl 中的 ViewRepository 转到 BusinessService -->
        <replaceregexp match="(\w+)ViewRepository" replace="\1BOService" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.${view-layer-name}\.repository\.(\w+)BOService"
                       replace=".business.service.\1BOService"
                       flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.\w+\.service\.((MailService)|(UserService)|(AuditEventService))\b"
                       replace=".business.service.\1"
                       flags="g">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}" includes="**/*.java" />
        </replaceregexp>
         
        <!--  -->
    </target>
    
    <!-- 直接调用处理文件，提取文件中的内容生成新的directive。参数是 filepath -->
    <target name="gen.process.vo.gen-directive" >
        <!-- 获取文件名的后缀，以便判断处理 -->
        <pathconvert property="stdfile" targetos="unix">
            <path location="${filepath}" />
        </pathconvert>
        <propertyregex property="file.path0" input="${stdfile}" regexp="([\w\d\-\./:]+)/([\w\-\.]+)/\2([\-\w]+)\.html" select="\1/\2" casesensitive="false" override="true" />
        <propertyregex property="file.dirname" input="${stdfile}" regexp="([\w\d\-\./:]+)/([\w\-\.]+)/\2([\-\w]+)\.html" select="\2" casesensitive="false" override="true" />
        <propertyregex property="file.postfix" input="${stdfile}" regexp="([\w\d\-\./:]+)/([\w\-\.]+)/\2([\-\w]+)\.html" select="\3" casesensitive="false" override="true" />
        <dash-name property="file.varname" value="${file.dirname}" />
        <echo level="debug" >
            filepath = ${filepath}
            stdfile = ${stdfile}
            path part = ${file.path0}
            dirname = ${file.dirname}
            postfix = ${file.postfix}
            varname = ${file.varname}
        </echo>
        <!-- 获取之后，file.postfix可能取值为 s，-dialog，-detail， -delete-dialog，开始提取文件内容，修改之后保存到新文件中 -->
        <loadfile property="file.content" srcfile="${stdfile}" />
        <switch value="${file.postfix}">
            <case value="s">
                <!-- 带编辑的表格 -->
                <antcall target="gen.process.vo.gen-list-edit-directive" >
                </antcall>
                <!-- 只可列举的，不带编辑的表格 -->
                <antcall target="gen.process.vo.gen-list-directive" >
                </antcall>
            </case>
            <case value="-dialog">
                <!--  -->
                <antcall target="gen.process.vo.gen-edit-directive" >
                </antcall>
            </case>
            <case value="-detail">
                <!--  -->
                <antcall target="gen.process.vo.gen-info-directive" >
                </antcall>
            </case>
            <case value="-delete-dialog">
                <!--  -->
                <antcall target="gen.process.vo.gen-delete-directive" >
                </antcall>
            </case>
            <default>
                <echo message="unknown file postfix value [${file.postfix}]" />
            </default>
        </switch>
        <!-- 替换index.html里边的script部分 -->
        <property name="index-js-scripts"><![CDATA[
    <script src="app/entities/${file.dirname}/${file.dirname}-dialog.controller.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}-detail.controller.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}-delete-dialog.controller.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}-edit.controller.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}-info.controller.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}-list.controller.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}-list-edit.controller.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}.state.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}.service.js"></script>
    <script src="app/entities/${file.dirname}/${file.dirname}.controller.js"></script>        
]]></property>
        <propertyregex property="file.dirname.regex" override="true" global="true"
            input="${file.dirname}" regexp="([\.\-\&gt;\&lt;])" replace="\\$1" 
        />
        <property name="index-js-regex0"><![CDATA[<script\s+src="app/entities/${file.dirname.regex}[\s[^\s]]+${file.dirname.regex}/${file.dirname.regex}\.controller\.js">\s*</script>]]></property>
        <propertyregex property="index-js-regex" override="true" global="true"
            input="${index-js-regex0}" regexp="([\&gt;\&lt;])" replace="\\$1" 
        />
        
        <replaceregexp match="[\r\n\s]*${index-js-regex}[\r\n\s]*" replace="${index-js-scripts}" flags="gm">
            <fileset dir="${source_merge_dir}/main/webapp" includes="index.html" />
        </replaceregexp>
    </target>
    
    <target name="gen.process.vo.gen-list-edit-directive" >
        <propertyregex property="file.new-content" override="true" input="${file.content}" casesensitive="false" global="true"
                       regexp="\&lt;div\&gt;[\r\n\s]+\&lt;h2\s+data\-translate=[\s[^\s]]+(\&lt;div\s+class=&quot;table\-responsive\s*&quot;[\s[^\s]]+)\&lt;div\s+class=&quot;text\-center\s*&quot;\&gt;[\s\r\n]+\&lt;jhi\-item\-count"
                       select="\1" />
        <echo level="debug">list file content=[${file.new-content}]</echo>
        <!-- 生成新文件 -->
        <echo file="${file.path0}/${file.dirname}-list-edit.html">${file.new-content}</echo>
        <echo file="${file.path0}/${file.dirname}-list-edit.controller.js"><![CDATA[
(function() {
    'use strict';

    var ${file.varname}ListEdit = {
        bindings: {
            ${file.varname}s: '='
        },
        controller: ${file.varname}ListEditController,

        templateUrl: 'app/entities/${file.dirname}/${file.dirname}-list-edit.html'
    };

    angular
        .module('${project_name}App')
        .component('${file.varname}ListEdit', ${file.varname}ListEdit);

    ${file.varname}ListEditController.$inject = ['$scope'];

    function ${file.varname}ListEditController($scope) {
        var vm = this;
        vm.vm = {
            ${file.varname}s: this.${file.varname}s
        };
    }
})();            

        ]]></echo>
    </target>

    <target name="gen.process.vo.gen-list-directive" >
        <propertyregex property="file.new-content-0" override="true" input="${file.content}" casesensitive="false" global="true"
                       regexp="\&lt;div\&gt;[\r\n\s]+\&lt;h2\s+data\-translate=[\s[^\s]]+(\&lt;div\s+class=&quot;table\-responsive\s*&quot;[\s[^\s]]+)\&lt;div\s+class=&quot;text\-center\s*&quot;\&gt;[\s\r\n]+\&lt;jhi\-item\-count"
                       select="\1" />
        <propertyregex property="file.new-content" override="true" input="${file.new-content-0}" casesensitive="false" global="true"
                       regexp="([\s[^\s]]+)\&lt;td class=&quot;text-right&quot;\&gt;[\s\r\n]+\&lt;div class=&quot;btn-group flex-btn-group-container&quot;\&gt;[\s[^\s]]+\&lt;/button\&gt;[\s\r\n]+\&lt;/div\&gt;[\s\r\n]+\&lt;/td\&gt;[\s\r\n]+(\&lt;/tr\&gt;[\s[^\s]]+)"
                       select="\1\2" />
        <echo level="debug">list file info=[${file.new-content}]</echo>
        <!-- 生成新文件 -->
        <echo file="${file.path0}/${file.dirname}-list.html">${file.new-content}</echo>
        <echo file="${file.path0}/${file.dirname}-list.controller.js"><![CDATA[
(function() {
    'use strict';

    var ${file.varname}List = {
        bindings: {
            ${file.varname}s: '='
        },
        controller: ${file.varname}ListController,

        templateUrl: 'app/entities/${file.dirname}/${file.dirname}-list.html'
    };

    angular
        .module('${project_name}App')
        .component('${file.varname}List', ${file.varname}List);

    ${file.varname}ListController.$inject = ['$scope'];

    function ${file.varname}ListController($scope) {
        var vm = this;
        vm.vm = {
            ${file.varname}s: this.${file.varname}s
        };
    }
})();            

        ]]></echo>
    </target>

    <target name="gen.process.vo.gen-edit-directive" >
        <propertyregex property="file.new-content" override="true" input="${file.content}" casesensitive="false" global="true"
            regexp="[\s[^\s]]+jhi\-alert\-error\&gt;[\s[^\s]]+\&lt;input\s+type=&quot;text&quot;\s+class=&quot;form-control&quot;(.+[\s\r\n]+.+ng\-model=.+)\s+readonly\s+/\&gt;[\r\n\s]+\&lt;/div\&gt;([\s[^\s]]+)\&lt;/div\&gt;[\r\n\s]+\&lt;div\s+class=&quot;modal\-footer[\s[^\s]]+\&lt;/button\&gt;[\r\n\s]+\&lt;/div\&gt;[\r\n\s]+\&lt;/form\&gt;"
            select="&lt;input type=&quot;hidden&quot; \1 /&gt;\2" />
        <echo level="debug">edit dialog=[${file.new-content}]</echo>
        <!-- 生成新文件 -->
        <echo file="${file.path0}/${file.dirname}-edit.html">${file.new-content}</echo>
        <echo file="${file.path0}/${file.dirname}-edit.controller.js"><![CDATA[
(function() {
    'use strict';

    var ${file.varname}Edit = {
        bindings: {
            ${file.varname}: '='
        },
        controller: ${file.varname}EditController,

        templateUrl: 'app/entities/${file.dirname}/${file.dirname}-edit.html'
    };

    angular
        .module('${project_name}App')
        .component('${file.varname}Edit', ${file.varname}Edit);

    ${file.varname}EditController.$inject = ['$scope'];

    function ${file.varname}EditController($scope) {
        var vm = this;
        vm.vm = {
            ${file.varname}: this.${file.varname}
        };
    }
})();            

        ]]></echo>
    </target>
    
    <target name="gen.process.vo.gen-info-directive" >
        <propertyregex property="file.new-content" override="true" input="${file.content}" casesensitive="false" global="true"
            regexp="\&lt;/jhi-alert-error\&gt;[\r\n\s]+(\&lt;dl class=[\s[^\s]]+\&lt;/dl\&gt;)[\r\n\s]+\&lt;button type=&quot;submit&quot;"
            select="\1" />
        <echo level="debug">detail file content=[${file.new-content}]</echo>
        <!-- 生成新文件 -->
        <echo file="${file.path0}/${file.dirname}-info.html">${file.new-content}</echo>
        <echo file="${file.path0}/${file.dirname}-info.controller.js"><![CDATA[
(function() {
    'use strict';

    var ${file.varname}Info = {
        bindings: {
            ${file.varname}: '='
        },
        controller: ${file.varname}InfoController,

        templateUrl: 'app/entities/${file.dirname}/${file.dirname}-info.html'
    };

    angular
        .module('${project_name}App')
        .component('${file.varname}Info', ${file.varname}Info);

    ${file.varname}InfoController.$inject = ['$scope'];

    function ${file.varname}InfoController($scope) {
        var vm = this;
        vm.vm = {
            ${file.varname}: this.${file.varname}
        };
    }
})();            

        ]]></echo>
    </target>
    
    <target name="gen.process.vo.gen-delete-directive" >  
        <echo>delete dialog file content=[${file.content}]</echo>
        <!-- delete 不要做任何事情 -->
    </target>
    
    <target name="gen.merge.bo" if="${is_bo}">
        <echo message="合并 BO 层文件" />
        <copy todir="${source_merge_dir}" verbose="true" >
            <fileset dir="${output_dir}/bo/src">
                <include name="main/java/${project_package_dir}/business/domain/*BO.java" />
                <include name="main/java/${project_package_dir}/business/service/**/*.java" />
                <exclude name="main/java/${project_package_dir}/business/service/dto/*.java" />
            </fileset>
        </copy>
        <copy todir="${source_merge_dir}/main/java/${project_package_dir}" verbose="true" >
            <fileset dir="${output_dir}/bo/src/main/java/${project_package_dir}/business">
                <include name="aop/**/*.java" />
                <include name="config/**/*.java" />
                <include name="util/**/*.java" />
            </fileset>
        </copy>
    </target>

    <!-- 修复 BO 内部的链接关系，确保没有编译错误 -->
    <target name="gen.fix.bo" if="${is_bo}">
        <!-- 装入 CacheConfiguration 中的新内容，然后添加到原来的同名文件中 -->
        <!--
        <loadfile property="bo_config_file"
                  srcfile="${output_dir}/bo/src/main/java/${project_package_dir}/business/config/CacheConfiguration.java">
        </loadfile>
        <propertyregex property="bo_config_code"
                       override="true"
                       input="${bo_config_file}"
                       regexp="User\.class\.getName.+\.persistent.+[\r\n]+([;\w\d\.\r\n\s\*@\(\)\{\}=,\&lt;\&gt;\-\+\&quot;]+)"
                       select="\1"
                       casesensitive="false"
                       global="true" />

        <echo>bo_config_code=[${bo_config_code}]</echo>
        <replaceregexp match="(^\s+// jhipster-needle\-ehcache\-add\-entry\s*$)"
                       replace="${bo_config_code}\1"
                       flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/${view-layer-name}/config"
                     includes="CacheConfiguration.java" />
        </replaceregexp>
        -->
        <!-- 替换 BOServiceImpl 中的 BORepository 转到 PORepository -->
        <replaceregexp match="(\w+)BORepository" replace="\1PORepository" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.business\.repository\.(\w+)PORepository"
                       replace=".po.repository.\1PORepository"
                       flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.business\.repository\."
                       replace=".po.repository."
                       flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business" includes="**/*.java" />
        </replaceregexp>
        <!-- 将所有的 BOMapper 输出对象替换成 PO -->
        <replaceregexp match="(\w+)BO\b" replace="\1PO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business">
                <include name="**/*.java" />
                <exclude name="domain/*BO.java" />
            </fileset>
        </replaceregexp>
        <replaceregexp match="\.business\.domain\.(\w+)PO" replace=".po.domain.\1PO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business"
                     includes="**/*.java" />
        </replaceregexp>
        <!-- 将 BODTO 转到 BO -->
        <replaceregexp match="(\w+)BODTO\b" replace="\1BO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.business\.service\.dto\.(\w+)BO" replace=".business.domain.\1BO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business/service"
                     includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="\.business\.service\.dto\.UserDTO" replace=".${view-layer-name}.service.dto.UserDTO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business/service"
                     includes="**/*.java" />
        </replaceregexp>
        <!-- 在mapper里投机取巧一下，将BO的import替换成PO -->
        <replaceregexp match="\.business\.domain\.(\w+)BO" replace=".po.domain.\1PO" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/business/service/mapper"
                     includes="**/*.java" />
        </replaceregexp>
        <!-- 修改 aspect 里的参数饮用 -->
        <replaceregexp match=".business.repository." replace=".po.repository" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/aop"
                     includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match=".business.web." replace=".${view-layer-name}.web." flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/aop"
                     includes="**/*.java" />
        </replaceregexp>
   
        
    </target>

    <target name="gen.merge.po" if="${is_po}">
        <echo message="合并 PO 层文件" />
        <copy todir="${source_merge_dir}" verbose="true" >
            <fileset dir="${output_dir}/po/src">
                <include name="main/java/${project_package_dir}/po/repository/*.java" />
                <include name="main/java/${project_package_dir}/po/domain/*.java" />
            </fileset>
        </copy>
        <copy todir="${source_merge_dir}/main/java/${project_package_dir}" verbose="true" >
            <fileset dir="${output_dir}/po/src/main/java/${project_package_dir}/po">
                <include name="config/CacheConfiguration.java" />
            </fileset>
        </copy>
    </target>

    <!-- 修复 PO 内部的链接关系，确保没有编译错误 -->
    <target name="gen.fix.po" if="${is_po}">
        
    </target>

    <!-- 修复文件内部的链接关系，完成 vo-bo-po 的关联，确保没有编译错误 -->
    <target name="gen.fix" depends="gen.fix.vo, gen.fix.bo, gen.fix.po">
        <!-- 修复因为移动导致的package问题 -->
        <replaceregexp match="${project_package}\.\w+\.aop\b" replace="${project_package}.aop" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="${project_package}\.\w+\.config\b" replace="${project_package}.config" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="${project_package}\.\w+\.util\b" replace="${project_package}.util" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <!-- 修复 User， Authority 等几个预定义对象的饮用 -->
        <replaceregexp match="${project_package}\.\w+\.(\w+)\.User(Repository)?\b" replace="${project_package}.po.\1.User\2" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="${project_package}.\w+.domain.Authority" replace="${project_package}.po.domain.Authority" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="${project_package}\.\w+\.(\w+)\.PersistentToken(Repository)?\b" replace="${project_package}.po.\1.PersistentToken\2" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="${project_package}\.\w+\.security\." replace="${project_package}.security." flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <replaceregexp match="${project_package}\.\w+\.domain\.PersistentAuditEvent" replace="${project_package}.po.domain.PersistentAuditEvent" flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}" includes="**/*.java" />
        </replaceregexp>
        <!-- 处理 config Constants 的引用 -->
        <replaceregexp match="${project_package}\.\w+\.config\." replace="${project_package}.config." flags="gm">
            <fileset dir="${source_merge_dir}/main/java/${project_package_dir}/" includes="**/*.java" />
        </replaceregexp>
    </target>

    <!-- 从文件内部提取自定义符号，提升数据转换的灵活性 -->
    <target name="gen.improve">
    </target>

</project>